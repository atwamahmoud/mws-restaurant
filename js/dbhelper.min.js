class DBHelper{static get RESTAURANT_DATABASE_URL(){return'http://localhost:1337/restaurants'}
static get REVIEWS_DATABASE_URL(){return'http://localhost:1337/reviews/'}
static get IDB_VERSION(){return 1}
static get IDB_NAME(){return'restaurants'}
static get FETCHED_RESTAURANTS_REVIEWS(){return localStorage.getItem('fetch-reviews')}
static AddFetchedReview(restaurant_id){if(!DBHelper.FETCHED_RESTAURANTS_REVIEWS){localStorage.setItem('fetch-reviews',JSON.stringify([restaurant_id]))}else{let arr=JSON.parse(DBHelper.FETCHED_RESTAURANTS_REVIEWS);arr.push(restaurant_id);localStorage.setItem('fetch-reviews',JSON.stringify(arr))}}
static get INTERSECTION_OBSERVER(){const observer=new IntersectionObserver(entries=>{for(const entry of entries){if(entry.isIntersecting){let img=entry.target;img.setAttribute('src',img.getAttribute('data-src'));observer.unobserve(img)}}})
return observer}
static registerSW(){return navigator.serviceWorker.register('sw.js')}
static openDB(){return new Promise((resolve,reject)=>{const req=indexedDB.open(DBHelper.IDB_NAME,DBHelper.IDB_VERSION);req.onupgradeneeded=(e)=>{const currentVersion=e.oldVersion;const db=req.result;switch(currentVersion){case 0:db.createObjectStore('restaurants',{keyPath:'name'});db.createObjectStore('reviews',{keyPath:'updatedAt'});e.target.transaction.complete}
db.onsuccess=e=>{resolve(db)}
db.onerror=e=>{reject(e.target)}}
req.onerror=e=>{reject(e.target)}
req.onsuccess=(e)=>{resolve(req.result)}})}
static getCachedRestaurants(){return DBHelper.openDB().then(db=>{const tx=db.transaction('restaurants');const store=tx.objectStore('restaurants');const req=store.getAll();return new Promise((resolve,reject)=>{req.onsuccess=e=>{resolve(e.target.result)}
req.onerror=e=>{reject(e.target)}})}).catch(err=>{console.error(err)})}
static getCachedReviews(){return DBHelper.openDB().then(db=>{const tx=db.transaction('reviews');const store=tx.objectStore('reviews');const req=store.getAll();return new Promise((resolve,reject)=>{req.onsuccess=e=>{resolve(e.target.result)}
req.onerror=e=>{reject(e.target)}})}).catch(err=>{console.error(err)})}
static addRestaurants(restaurants){return DBHelper.openDB().then(db=>{const tx=db.transaction('restaurants','readwrite');const store=tx.objectStore('restaurants');for(const restaurant of restaurants){const req=store.put(restaurant)}})}
static addFailedReview(review){return caches.open('failed-requests').then(cache=>{const resp=new Response(JSON.stringify(review),{type:'application/json'})
cache.put(review.url,resp)})}
static addReviews(reviews,isResponse=!1){return DBHelper.openDB().then(db=>{const tx=db.transaction('reviews','readwrite');const store=tx.objectStore('reviews');for(const review of reviews){if(isResponse){const updateTime=new Date(review.updatedAt)
review.updatedAt=updateTime.getTime()}
const req=store.put(review)}})}
static fetchRestaurants(callback){this.registerSW();return DBHelper.getCachedRestaurants().then(restaurants=>{if(restaurants.length>0)return restaurants;else return fetch(DBHelper.RESTAURANT_DATABASE_URL)}).then(resp=>{if(resp.status===undefined)return resp;else if(resp.status===200)return resp.json();else{const error=(`Request failed. Returned status of ${resp.status}`);callback(error,null)}}).then(restaurants=>{if(restaurants)
DBHelper.addRestaurants(restaurants).then(_=>callback(null,restaurants.reverse()))})}
static fetchAndAddBuiltInReviews(callback){return DBHelper.getCachedReviews().then(reviews=>{if(reviews.length>30)return reviews;return fetch(DBHelper.REVIEWS_DATABASE_URL)}).then(resp=>{if(resp.status===undefined)return resp;else if(resp.status===200)return resp.json();else{const error=(`Request failed. Returned status of ${resp.status}`);callback(error,null)}}).then(reviews=>{if(reviews)
DBHelper.addReviews(reviews).then(_=>callback(null,reviews))})}
static fetchReviews(callback,restaurant_id=0){return DBHelper.getCachedReviews().then(reviews=>{if(restaurant_id>0){return fetch(DBHelper.REVIEWS_DATABASE_URL+`?restaurant_id=${restaurant_id}`)}
else{if(reviews.length>0)return reviews;return fetch(DBHelper.REVIEWS_DATABASE_URL)}}).then(resp=>{if(resp.status===undefined)return resp;else if(resp.status===200)return resp.json();else{const error=(`Request failed. Returned status of ${resp.status}`);callback(error,null)}}).then(reviews=>{if(reviews)
DBHelper.addReviews(reviews).then(_=>callback(null,reviews.reverse()))}).catch(err=>{console.error(err);DBHelper.getCachedReviews().then(reviews=>callback(null,reviews.reverse()))})}
static fetchRestaurantById(id,callback){DBHelper.fetchRestaurants((error,restaurants)=>{if(error){callback(error,null)}else{const restaurant=restaurants.find(r=>r.id==id);if(restaurant){callback(null,restaurant)}else{callback('Restaurant does not exist',null)}}})}
static fetchReviewsByRestaurantId(id,callback){const fetchedRestaurants=DBHelper.FETCHED_RESTAURANTS_REVIEWS;let idToBePassed=id;if(!fetchedRestaurants||!fetchedRestaurants.includes(id)){DBHelper.AddFetchedReview(id)}else idToBePassed=0;DBHelper.fetchReviews((error,reviews)=>{if(error){callback(error,null)}else{let reviewsArray=reviews.filter(r=>{return r.restaurant_id==id});if(reviewsArray){callback(null,reviewsArray)}else{callback('Restaurant does not exist',null)}}},idToBePassed)}
static fetchRestaurantByCuisine(cuisine,callback){DBHelper.fetchRestaurants((error,restaurants)=>{if(error){callback(error,null)}else{const results=restaurants.filter(r=>r.cuisine_type==cuisine);callback(null,results)}})}
static fetchRestaurantByNeighborhood(neighborhood,callback){DBHelper.fetchRestaurants((error,restaurants)=>{if(error){callback(error,null)}else{const results=restaurants.filter(r=>r.neighborhood==neighborhood);callback(null,results)}})}
static fetchRestaurantByCuisineAndNeighborhood(cuisine,neighborhood,callback){DBHelper.fetchRestaurants((error,restaurants)=>{if(error){callback(error,null)}else{let results=restaurants
if(cuisine!='all'){results=results.filter(r=>r.cuisine_type==cuisine)}
if(neighborhood!='all'){results=results.filter(r=>r.neighborhood==neighborhood)}
callback(null,results)}})}
static fetchNeighborhoods(callback){DBHelper.fetchRestaurants((error,restaurants)=>{if(error){callback(error,null)}else{const neighborhoods=restaurants.map((v,i)=>restaurants[i].neighborhood)
const uniqueNeighborhoods=neighborhoods.filter((v,i)=>neighborhoods.indexOf(v)==i)
callback(null,uniqueNeighborhoods)}})}
static fetchCuisines(callback){DBHelper.fetchRestaurants((error,restaurants)=>{if(error){callback(error,null)}else{const cuisines=restaurants.map((v,i)=>restaurants[i].cuisine_type)
const uniqueCuisines=cuisines.filter((v,i)=>cuisines.indexOf(v)==i)
callback(null,uniqueCuisines)}})}
static urlForRestaurant(restaurant){return(`./restaurant.html?id=${restaurant.id}`)}
static imageUrlForRestaurant(restaurant){if(!restaurant.photograph)return'./img/webp/notAvailable.webp';return(`./img/webp/${restaurant.photograph}.webp`)}
static mapMarkerForRestaurant(restaurant,map){const marker=new google.maps.Marker({position:restaurant.latlng,title:restaurant.name,url:DBHelper.urlForRestaurant(restaurant),map:map,animation:google.maps.Animation.DROP});return marker}}